## 缓存

本地缓存有很多优秀的开源库，go的如groupcache等  
这里主要讲缓存中间件redis

### Redis

**介绍redis**
```
C语言开发的内存数据库，所以速度非常快
除了做缓存之外，也适合做分布式锁，甚至是消息队列

优点
读写性能优异
支持数据持久化，AOF，RDB
支持事物，redis的所有操作都是原子性的，同时也支持操作合并的原子性执行
数据结构丰富，string、hash、list、set、zset等
支持主从复制，读写分离

缺点
数据容量受物理内存限制，不能做海量数据的高性能读写
不具备主动容错和恢复功能
主机宕机，数据未及时同步到从机，切换ip还会引入数据不一致问题，降低了系统的可用性
较难支持在线扩容
```

**redis为什么这么快**
```
1.完全基于内存，数据存在于内存中，哈希，查找和读取都是O(1)
2.数据结构简单
3.采用单线程，避免了不必要的上下文切换和竞争条件，没有锁，没有线程切换对cpu的消耗
4.使用多路I/O复用模型，非阻塞IO
```

**redis持久化**
```
rdb
fork子进程来完成写操作，所以IO最大化，保证性能
数据较大时，比AOF的启动效率更高
不过同步时间会导致数据安全性没有保障，如果可以承受数分钟内的数据丢失，这种策略也是很好的选择

aof
将每次执行的命令保存到单独的日志文件中，会定期整理
更新频率高，两个都配置了会优先加载aof
aof的文件显然会比rdb大，但是数据更安全，数据大的时候启动效率低

如果你只需要运行时缓存数据，数据持久化也是完全可以不配置的
```

**redis过期策略**
```
1.定时过期
每个key都创建一个定时器，到过期时间立即删除，利好内存，缺点是占用大量cpu

2.惰性过期
访问key的时候才会去判断是否删除，对内存不友好，相对利好cpu

3.定期过期
平衡了以上两种过期策略，时间设置的好的情况下，是可以表现优异的
```

**集群方案**
```
TODO
```


**缓存穿透**
```
指的是查询缓存中不存在的数据，每次都要去db中查询
解决方式：
1.缓存空值
2.布隆过滤器，将所有可能的数据哈希存到一个足够大的bitmap中，像是数据库的缩略版
```

**缓存雪崩**
```
指的是大量数据设置了相同的过期时间，某个时刻同时失效，大量瞬时压力给到db
解决方式：
1.缓存时间分散，如设置随机值
```

**缓存击穿**
```
大量的请求同时查询某个key，而这个key此时刚好失效了
解决方式：
1.加互斥锁
```



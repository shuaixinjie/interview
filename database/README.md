## 数据库

最典型的关系型数据库莫过于mysql，这里只讲mysql，后续有时间会扩展其他数据库  

### MySQL 
mysql目前已被Oracle公司收购，为了防止其闭源，拉了个分支mariadb数据库

**mysql的锁**
```
表级锁：开销小，加锁快，不会出现死锁，并发度最低
行级锁：开销大，加锁慢，会出现死锁，并发度最高
页面锁：均衡与上两者之间
```

**mysql性能优化**
```
1.只查找一行数据的时候，建议加上limit 1，不然会在找到结果后继续搜索
2.用 not exists 代替 not in，能狗利用好索引，not in 不能使用索引
3.尽量不采用不利于索引的操作符，如：in /not in /is null /is not null /<> 等
4.分库分表，主从配置
5.存储过程执行比一条一条地执行其中的各条语句快
6.决不要检索比需求还要多的数据
7.索引改善数据检索的性能，但是损害了数据插入删除更新的性能
8.like很慢，一般来说最好使用fulltext而不是like
9.如果从一个表中删除大量数据，应该使用optimize table回收所用的空间，从而优化表性能
10.char比varchar效率高很多，因此确定字符长度字段最好使用char字段
11.随机获取数据时， 避免使用order by rand() limit, 效率会很慢， 建议使用join
```

**事物的四大特征**
```
1.原子性 事务开始后所有操作，要么全部做完，要么全部不做
2.一致性 事务开始前和结束后，数据库的完整性约束没有被破坏 
3.隔离性 同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰
4.持久性 事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚
```


**MyISAM和InnoDB**
```
MyISAM：
不支持事物，每次查询都是原子的
支持表级锁
非聚集索引

InnoDb：
支持ACID的事务，支持事务的四种隔离级别
支持行级锁及外键约束：因此可以支持写并发
聚集索引
```

**mysql的隔离级别**
```
1.read uncommited 如果事物被回滚，会导致脏读
2.read commited 不可重复读，和读已提交情况相反
3.repeatable read 读已提交对修改数据无能为力，而可重复读，对新增数据束手无策，可能会存在幻读，mysql的默认策略
4.serializable 可能是最安全但是性能最差的策略
```

**数据库三大范式**
```
1.列的原子性
2.行的唯一性
3.非主键必须直接依赖主键

特殊时候也需要反模式创建表
```

**索引**
```
MySQL数据库的索引是帮助MySQL高效获取数据的一种数据结构
普通索引、唯一索引、主键索引、组合索引、外键索引、全文索引
```

**乐观锁和被关锁**
```
悲观锁
行锁、表锁都是悲观锁，操作数据直接加锁

乐观锁
读远大于写的时候，乐观锁很好用
```




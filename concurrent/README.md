## 并发

### 进程
```
进程好比是一个程序，它是CPU资源分配的基本单位
进程拥有自己的资源空间，一个进程包含若干个线程
```

### 线程
```
它是程序执行过程中的最小单元
CPU上真正运行的是线程
线程与CPU资源分配无关，多个线程共享同一进程内的资源
线程的调度与切换比进程快很多
```

### 协程
```
协程是一种用户态的轻量级线程
协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈
协程能保留上一次调用时的状态（即所有局部状态的一个特定组合），每次过程重入时，就相当于进入上一次调用的状态，换种说法：进入上一次离开时所处逻辑流的位置
线程在多核的环境下是能做到真正意义上的并行执行的,而协程是为并发而生的,go可以设置多核
```

### 锁

死锁的触发条件
```
相互排斥：并发进程同时拥有资源的独占权
等待条件：并发进程必须同时拥有一个资源，并等待额外的资源
没有抢占：并发进程拥有的资源只能被该进程释放，即可满足这个条件
循环等待：一个并发进程p1必须等待一系列其他进程p2，这些并发进程同时也在等待p1，这样便满足了这个最终的条件
```

golang中的锁
```
互斥锁 sync.Mutex
读写锁 sync.RWMutex 
区别是读写锁可以并发读，其他没区别
```

